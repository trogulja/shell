#!/usr/bin/env zsh
# p - Smart dispatcher for Productive repository scripts
# Usage: p [OPTIONS]
#
# Detects the current repository and runs the appropriate prun-* script.
# Passes all arguments to the underlying script.

set -e

# Load common functions (must be at top level)
local SCRIPT_FOLDER="${0:A:h}"
source "${SCRIPT_FOLDER}/p-common.zsh"

# Build registry by scanning prun-* files
typeset -A SCRIPT_REGISTRY
for script in "${SCRIPT_FOLDER}"/prun-*; do
  local expected_repo=$(grep '^typeset -r EXPECTED_REPO=' "$script" | cut -d'"' -f2)
  local script_name="${script:t}"
  SCRIPT_REGISTRY[$expected_repo]="$script_name"
done

show_help_and_exit() {
  cat << EOF
p - Smart dispatcher for Productive repository scripts

USAGE:
  p [OPTIONS]

DESCRIPTION:
  Automatically detects which Productive repository you're in and runs
  the appropriate prun-* script. Works from any subdirectory within
  the repository.

  All options are passed through to the underlying prun-* script.

SUPPORTED REPOSITORIES:
$(for repo in "${(@k)SCRIPT_REGISTRY}"; do echo "  - $repo (${SCRIPT_REGISTRY[$repo]})"; done)

REQUIREMENTS:
  - Must be run from within a supported repository
  - Requires pdetect and jq to be installed
EOF
  exit 0
}

main() {
  # Check required commands
  check_command pdetect
  check_command jq

  # Detect repository
  local result
  result=$(pdetect 2>/dev/null) || show_help_and_exit

  local repo
  repo=$(echo "$result" | jq -r .repo 2>/dev/null) || show_help_and_exit

  # Check if repo is registered
  if [[ -z "${SCRIPT_REGISTRY[$repo]}" ]]; then
    show_help_and_exit
  fi

  # Get the script name from registry
  local script_name="${SCRIPT_REGISTRY[$repo]}"
  local script_path="${SCRIPT_FOLDER}/${script_name}"

  # Verify script exists
  check_command "$script_path"

  # Execute the registered script with all arguments
  exec "$script_path" "$@"
}

# Run main function
main "$@"
